---
title: "Dijkstra’s Algorithm — A Practical Mini‑Guide"
description: "Shortest paths on weighted graphs with visuals, tables, and quick stats."
date: 2025-08-22
---

import { useState } from 'react'

# Dijkstra’s Algorithm

> Find the shortest paths from a single source to all other vertices in a **non‑negative weighted** graph.

## When to use it
- You have **non‑negative edge weights** (0 or positive).
- You need **single‑source** shortest paths.
- You want a fast, deterministic solution.

---

## Visual: a tiny graph

This inline SVG shows a small weighted directed graph. The goal is the shortest paths from **A**.

<svg viewBox="0 0 420 180" width="100%" role="img" aria-label="Tiny weighted graph">
  <defs>
    <marker id="arrow" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
      <path d="M 0 0 L 10 5 L 0 10 z" />
    </marker>
  </defs>
  <!-- nodes -->
  <circle cx="60" cy="90" r="18" />
  <text x="60" y="95" textAnchor="middle" fontSize="14">A</text>
  <circle cx="180" cy="40" r="18" />
  <text x="180" y="45" textAnchor="middle" fontSize="14">B</text>
  <circle cx="180" cy="140" r="18" />
  <text x="180" y="145" textAnchor="middle" fontSize="14">C</text>
  <circle cx="320" cy="90" r="18" />
  <text x="320" y="95" textAnchor="middle" fontSize="14">D</text>

  <!-- edges with weights -->
  <line x1="78" y1="83" x2="162" y2="47" stroke="currentColor" markerEnd="url(#arrow)" />
  <text x="120" y="60" fontSize="12">4</text>

  <line x1="78" y1="97" x2="162" y2="133" stroke="currentColor" markerEnd="url(#arrow)" />
  <text x="120" y="122" fontSize="12">2</text>

  <line x1="198" y1="40" x2="302" y2="90" stroke="currentColor" markerEnd="url(#arrow)" />
  <text x="250" y="50" fontSize="12">5</text>

  <line x1="198" y1="140" x2="302" y2="90" stroke="currentColor" markerEnd="url(#arrow)" />
  <text x="250" y="135" fontSize="12">1</text>

  <line x1="190" y1="55" x2="190" y2="125" stroke="currentColor" markerEnd="url(#arrow)" />
  <text x="200" y="92" fontSize="12">3</text>
</svg>

**Observation:** From A→C (2)→D (1) is cheaper than A→B (4)→D (5).

---

## Algorithm (min‑heap / priority queue)

```python
import heapq

def dijkstra(graph, src):
    # graph: dict[u] -> list[(v, w)] with w >= 0
    n = len(graph)
    INF = float('inf')
    dist = {u: INF for u in graph}
    parent = {u: None for u in graph}
    dist[src] = 0

    pq = [(0, src)]  # (distance, node)
    seen = set()

    while pq:
        d, u = heapq.heappop(pq)
        if u in seen:  # outdated entry
            continue
        seen.add(u)
        if d > dist[u]:
            continue
        for v, w in graph[u]:
            nd = d + w
            if nd < dist[v]:
                dist[v] = nd
                parent[v] = u
                heapq.heappush(pq, (nd, v))

    return dist, parent
```

**Complexities** (with adjacency lists):

| Data structure        | Time complexity                  | Space |
|---|---:|---:|
| Binary heap (min‑heap) | \(O((V + E) \log V)\)            | \(O(V)\) |
| Fibonacci heap*        | \(O(E + V \log V)\) amortized     | \(O(V)\) |
| Unoptimized (array)    | \(O(V^2 + E)\)                    | \(O(V)\) |

> *Great asymptotics, but heavy constants & tricky implementation. In practice, a binary heap wins often.

---

## Step‑by‑step on the tiny graph

Initial distances: `A:0, B:∞, C:∞, D:∞`

| Iter | Picked (min) | Relaxed edges | Distances after |
|---:|:--|:--|:--|
| 1 | A(0) | A→B(4), A→C(2) | B:4, C:2, D:∞ |
| 2 | C(2) | C→D(1)          | D:3, B:4      |
| 3 | D(3) | —               | (final D=3)   |
| 4 | B(4) | B→D(5)          | no change     |

**Shortest distances from A:** A:0, B:4, C:2, D:3.  
**Paths:** A→C→D, A→B.

---

## Stats: tiny benchmark (illustrative)

| Graph size | Edges | Heap pops | Relaxations | D(A→*) mean dist |
|---:|---:|---:|---:|---:|
| 4   | 5    | 4        | 5           | 3.0 |
| 1k  | 5k   | ~1k      | ~5k         | 412.7 |
| 1e5 | 6e5  | ~1e5     | ~6e5        | 16891.2 |

> Numbers are representative—not from a specific hardware run—showing how work scales roughly linearly with \(E\) (with a \(\log V\) factor from the heap).

### Visual: toy runtime vs. edges (E)

<svg viewBox="0 0 520 220" width="100%" role="img" aria-label="Runtime vs edges">
  <rect x="45" y="20" width="1" height="180" />
  <rect x="45" y="200" width="440" height="1" />
  <!-- bars: E=5,5k,6e5 (scaled) -->
  <rect x="80" y="180" width="40" height="20" />
  <rect x="200" y="120" width="40" height="80" />
  <rect x="360" y="40" width="40" height="160" />
  <text x="80" y="210" fontSize="12">5</text>
  <text x="200" y="210" fontSize="12">5k</text>
  <text x="360" y="210" fontSize="12">6e5</text>
  <text x="10" y="30" fontSize="12">time</text>
  <text x="480" y="215" fontSize="12">E</text>
</svg>

---

## Edge cases & gotchas
- **Negative weights?** Not allowed → use **Bellman–Ford** or **Johnson’s**.
- **Disconnected nodes?** They remain at \(\infty\) (unreachable).
- **Zero‑weight edges?** Fine. The algorithm still works.
- **Dense graphs (\(E\approx V^2\))?** A simple array‑based Dijkstra can be competitive.

---

## Quick interactive (MDX/React)

<Demo />

export default function Demo() {
  const [aToB, setAB] = useState(4)
  const [aToC, setAC] = useState(2)
  const [cToD, setCD] = useState(1)
  const [bToD, setBD] = useState(5)
  const best = Math.min(aToC + cToD, aToB + bToD)
  const route = best === aToC + cToD ? 'A→C→D' : 'A→B→D'
  return (
    <div style={{borderRadius:16,padding:16,boxShadow:'0 6px 24px rgba(0,0,0,0.08)'}}>
      <h3 style={{marginTop:0}}>A→D cost playground</h3>
      <p>Adjust edge weights (non‑negative) and see which path wins.</p>
      <div style={{display:'grid',gridTemplateColumns:'repeat(4,1fr)',gap:12}}>
        <label>A→B: <input type="number" min={0} value={aToB} onChange={e=>setAB(+e.target.value||0)} /></label>
        <label>A→C: <input type="number" min={0} value={aToC} onChange={e=>setAC(+e.target.value||0)} /></label>
        <label>C→D: <input type="number" min={0} value={cToD} onChange={e=>setCD(+e.target.value||0)} /></label>
        <label>B→D: <input type="number" min={0} value={bToD} onChange={e=>setBD(+e.target.value||0)} /></label>
      </div>
      <p style={{marginTop:12}}><strong>Best route:</strong> {route} &nbsp; <strong>Cost:</strong> {best}</p>
    </div>
  )
}

---

## Variants & relatives (cheat table)

| Problem | Non‑negative weights? | Multiple sources? | Typical pick |
|---|:--:|:--:|:--|
| Single‑source shortest paths | ✅ | — | Dijkstra (heap)
| With negative edges | ❌ | — | Bellman–Ford, SPFA
| All‑pairs shortest paths | ✅ | ✅ | Johnson’s (Dijkstra + reweighting) or Floyd–Warshall
| On unweighted graphs | — | — | BFS (each edge cost=1)

---

## Takeaways
- Use Dijkstra when edges are **non‑negative** and you need **single‑source** paths.
- Prefer a **binary heap** with adjacency lists; it’s fast, simple, and memory‑friendly.
- Watch out for **negative weights**—that’s a different algorithmic toolbox.
