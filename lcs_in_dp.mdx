---
title: Dynamic Programming - Subsequences
description: Learn how to solve subsequence-related problems using Dynamic Programming in C++
tags: [Dynamic Programming, Subsequences, C++]
---

import { CodeBlock } from '@components/CodeBlock'

# Dynamic Programming on Subsequences

Dynamic Programming (DP) is a powerful technique for solving problems involving subsequences.  
Common tasks include:
- Counting subsequences
- Finding the longest subsequence (increasing, common, etc.)
- Optimizing subsequence selection (max sum, min cost, etc.)

---

## ðŸ”¹ Problem Statement (Example: Longest Increasing Subsequence)

Given an array of integers, find the length of the **Longest Increasing Subsequence (LIS)**.

---

## ðŸ”¹ Input Format

- First line: integer `n` â€“ size of the array  
- Second line: `n` integers â€“ the elements of the array  

---

## ðŸ”¹ Output Format

A single integer â€“ the length of the LIS.

---

## ðŸ”¹ Constraints

- `1 â‰¤ n â‰¤ 10^5`  
- `-10^9 â‰¤ arr[i] â‰¤ 10^9`  

---

## ðŸ”¹ Example

**Input:**
6
10 9 2 5 3 7

makefile
Copy code

**Output:**
3

yaml
Copy code

Explanation: LIS is `[2, 5, 7]`.

---

## ðŸ”¹ Approach

There are two popular DP approaches:

### 1. **O(nÂ²) DP**
- For each element, check all previous elements.
- If `arr[j] < arr[i]`, update `dp[i] = max(dp[i], dp[j] + 1)`.

### 2. **O(n log n) Optimized (Patience Sorting + Binary Search)**
- Maintain a vector representing the smallest possible LIS ending at each length.
- Use `lower_bound` to place elements efficiently.

---

## ðŸ”¹ Code Implementation

<Code>

#include <bits/stdc++.h>
using namespace std;

// O(n log n) solution for LIS
int longestIncreasingSubsequence(vector<int>& arr) {
    vector<int> lis;
    for (int x : arr) {
        auto it = lower_bound(lis.begin(), lis.end(), x);
        if (it == lis.end())
            lis.push_back(x);
        else
            *it = x;
    }
    return lis.size();
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i];

    cout << longestIncreasingSubsequence(arr) << "\n";
    return 0;
}

</Code>

---

## ðŸ”¹ Complexity Analysis

- **O(nÂ²)** DP method â€“ good for `n â‰¤ 2000`  
- **O(n log n)** method â€“ works for `n â‰¤ 10^5`  

---

## ðŸ”¹ Applications

- **Sequence analysis** â€“ longest ordered subsequence, DNA/protein analysis  
- **Stock trading** â€“ finding increasing profit opportunities  
- **Competitive programming** â€“ subsequence-based optimization problems  

---