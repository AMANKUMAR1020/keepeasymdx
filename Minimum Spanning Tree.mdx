---
title: Minimum Spanning Tree in C++
description: Learn how to implement Kruskal's and Prim's algorithms for finding Minimum Spanning Trees using C++
tags: [C++, Graph Theory, Algorithms, MST]
---

import { CodeBlock } from '@components/CodeBlock'

# ðŸŒ³ Minimum Spanning Tree in C++

A **Minimum Spanning Tree (MST)** of a connected, undirected graph is a subset of the edges that connects all the vertices together, without any cycles and with the minimum possible total edge weight.

## ðŸ“˜ Why MST Matters

- Network design (e.g., laying cables or roads)
- Clustering algorithms
- Approximation algorithms for NP-hard problems

## ðŸ§  Algorithms to Find MST

### 1. Kruskal's Algorithm

- Sort all edges by weight
- Use a Union-Find (Disjoint Set) structure to avoid cycles
- Add edges one by one until all vertices are connected

<CodeBlock language="cpp">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

struct Edge {
    int u, v, weight;
    bool operator&lt;(Edge const& other) {
        return weight &lt; other.weight;
    }
};

int find(int v, vector&lt;int&gt;& parent) {
    if (v == parent[v])
        return v;
    return parent[v] = find(parent[v], parent);
}

void unite(int a, int b, vector&lt;int&gt;& parent, vector&lt;int&gt;& rank) {
    a = find(a, parent);
    b = find(b, parent);
    if (a != b) {
        if (rank[a] &lt; rank[b])
            swap(a, b);
        parent[b] = a;
        if (rank[a] == rank[b])
            rank[a]++;
    }
}

int main() {
    int n = 5; // number of vertices
    vector&lt;Edge&gt; edges = {
        {0, 1, 10}, {0, 2, 6}, {0, 3, 5}, {1, 3, 15}, {2, 3, 4}
    };

    sort(edges.begin(), edges.end());

    vector&lt;int&gt; parent(n), rank(n, 0);
    for (int i = 0; i &lt; n; i++)
        parent[i] = i;

    int cost = 0;
    for (Edge e : edges) {
        if (find(e.u, parent) != find(e.v, parent)) {
            cost += e.weight;
            unite(e.u, e.v, parent, rank);
            cout &lt;&lt; e.u &lt;&lt; " - " &lt;&lt; e.v &lt;&lt; " : " &lt;&lt; e.weight &lt;&lt; endl;
        }
    }

    cout &lt;&lt; "Total cost: " &lt;&lt; cost &lt;&lt; endl;
}
</CodeBlock>

### 2. Prim's Algorithm

- Start from any node
- Use a priority queue to pick the smallest edge connecting to the MST
- Repeat until all nodes are included

Primâ€™s is more efficient for dense graphs, while Kruskalâ€™s shines in sparse ones.

## ðŸ§ª Complexity Comparison

| Algorithm | Time Complexity | Best For |
|----------|------------------|-----------|
| Kruskal  | O(E log E)       | Sparse graphs |
| Prim     | O(E + V log V)   | Dense graphs |

## ðŸ§© Final Thoughts

Minimum Spanning Trees are a cornerstone of graph theory and optimization. Whether you're building networks or solving puzzles, MSTs offer elegant solutions with real-world impact.

---

Want to dive deeper into Primâ€™s implementation or visualize MSTs? Let me know and Iâ€™ll expand this module!
